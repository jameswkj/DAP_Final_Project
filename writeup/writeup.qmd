---
title: "Final Project"
author: "Kaijie(KJ) WU, Carey Cui, XiaoTian Tang"
date: today
date-format: long
format: 
    html:
        echo: false      
        code: false      
        toc: true        
        output: true     
engine: jupyter
---



This year, 2024, is an election year. We have witnessed a lot of big news: the withdrawal of Joe Biden and Donald Trump's return to the White House. Some states indicate that the turnout rate is lower than the election yeat in 2020. Alabama even declares the lowest turnout rate in over 30 years. These events make us interested in turnout rate. Our research questions are What factors affect turnout rate and how these fatocrs affect turnout rates.


The first factor that we are interested in is *State*. We plan to draw a map reflecting turnout rate in the state level. We use the [**State and National Turnout Rates for Presidential Elections**](https://election.lab.ufl.edu/voter-turnout/) data from the University of Florida Election Labï¼Œwhere it provides statewise presidential elections turnout rate data from 2012 to 2024. The geodata we use is [Census shapefile](https://www.census.gov/geographies/mapping-files/time-series/geo/carto-boundary-file.2010.html#list-tab-1556094155), specifically the zipfile "gz_2010_us_040_00_500k.zip". In the data cleaning process, we basically compared the 'State' columns in the four turnout rate dataset with the geodata using *set* function, to make sure the data be merged correctly. The app_fanciest.py is the shiny app that we created. Running this file with code *$shiny run --reload shiny/app_fanciest.py* in the terminal will display a shiny app with a drop-down menu selecting years, a check box to decide whether comparing the rate with nation level, and a toggle decide whether to showcase the swing states only. The results demonstrate that the Northern part of the US seems to have higher turnout rates than the Southern part, and the swing states, in most cases, have higher turnout rates than the national average.


```{python}
#|include: false
import pandas as pd
import geopandas as gpd
import altair as alt
import matplotlib.pyplot as plt
import os
os.chdir("/Users/tang/Desktop/DAP_Final_Project")


```


```{python}
#|include: false
df2012 = pd.read_csv('data/Turnout_2012G_v1.0.csv')
df2016 = pd.read_csv("data/Turnout_2016G_v1.0.csv")
df2020 = pd.read_csv("data/Turnout_2020G_v1.2.csv")
df2024 = pd.read_csv("data/Turnout_2024G_v0.3.csv")
geodata = gpd.read_file('data/gz_2010_us_040_00_500k/gz_2010_us_040_00_500k.shp')

geodata_states = set(geodata['NAME'])

### check if the state variable could match.(df2024)
df2024_states = set(df2024['STATE'])
common_geo_24= geodata_states & df2024_states
only_in_geodata = geodata_states - df2024_states
only_in_df2024 = df2024_states - geodata_states
print(f"Only in geodata['NAME']: {only_in_geodata}")
print(f"Only in df2024['STATE']: {only_in_df2024}")

### check if the state variable could match.(df2020)
df2020_states = set(df2020['STATE'])
common_geo_20= geodata_states & df2020_states
only_in_geodata = geodata_states - df2020_states
only_in_df2020 = df2020_states - geodata_states
print(f"Only in geodata['NAME']: {only_in_geodata}")
print(f"Only in df2020['STATE']: {only_in_df2020}")

# adjust Penn in df2020 by removing the astroid
df2020['STATE'] = df2020['STATE'].str.rstrip('*')


### check if the state variable could match.(df2016)
df2016_states = set(df2016['STATE'])
common_geo_16= geodata_states & df2016_states
only_in_geodata = geodata_states - df2016_states
only_in_df2016 = df2016_states - geodata_states
print(f"Only in geodata['NAME']: {only_in_geodata}")
print(f"Only in df2016['STATE']: {only_in_df2016}")

### check if the state variable could match.(df2012)
df2012_states = set(df2012['STATE'])
common_geo_12= geodata_states & df2012_states
only_in_geodata = geodata_states - df2012_states
only_in_df2012 = df2012_states - geodata_states
print(f"Only in geodata['NAME']: {only_in_geodata}")
print(f"Only in df2016['STATE']: {only_in_df2012}")

### define a data cleaning function
def df_cleaner(df):
    df_clean = df[['STATE', 'VEP_TURNOUT_RATE']].rename(columns={
        'STATE': 'NAME',
        'VEP_TURNOUT_RATE': 'VEP'})
    df_clean['VEP'] = df_clean['VEP'].str.replace(
        '%', '', regex=False).astype(float)
    df_clean['VEP_relative'] = (df_clean['VEP']-df_clean.loc[0,'VEP']).round(2)
    print(df_clean.loc[0,'VEP'])
    return df_clean


df2012_clean = df_cleaner(df2012)
df2016_clean = df_cleaner(df2016)
df2020_clean = df_cleaner(df2020)
df2024_clean = df_cleaner(df2024)

# export to local directory
df2012_clean.to_csv('data/df2012_clean.csv', index=False)
df2016_clean.to_csv('data/df2016_clean.csv', index=False)
df2020_clean.to_csv('data/df2020_clean.csv', index=False)
df2024_clean.to_csv('data/df2024_clean.csv', index=False)

```


```{python}
#|include: false
############
# the shiny app code is copy pasted here for your information.
############
from shiny import App, render, ui, reactive
from shinywidgets import render_altair, output_widget
import pandas as pd
import json
import altair as alt
import geopandas as gpd

# Import turnout rate data
df2012 = pd.read_csv('data/df2012_clean.csv')
df2016 = pd.read_csv('data/df2016_clean.csv')
df2020 = pd.read_csv('data/df2020_clean.csv')
df2024 = pd.read_csv('data/df2024_clean.csv')

# Import geodata
geodata = gpd.read_file('data/gz_2010_us_040_00_500k/gz_2010_us_040_00_500k.shp')

# Define swing states for each year
swing_states = {
    "2012": ["Florida", "Ohio", "Virginia", "Colorado", "Iowa", "New Hampshire", "Nevada", "North Carolina"],
    "2016": ["Florida", "Ohio", "Pennsylvania", "Michigan", "Wisconsin", "North Carolina", "Arizona", "Nevada"],
    "2020": ["Arizona", "Georgia", "Michigan", "Nevada", "North Carolina", "Pennsylvania", "Wisconsin"],
    "2024": ["Arizona", "Georgia", "Michigan", "Nevada", "North Carolina", "Pennsylvania", "Wisconsin"]
}

### UI
app_ui = ui.page_fluid(
    ui.h2("VEP Turnout Rate by State"),
    ui.layout_columns(
        ui.card(
            ui.card_header("Turnout Rate Map"),
            ui.input_select(
                id="year_select",
                label="Select Year:",
                choices=["2012", "2016", "2020", "2024"],  
                selected="2012"
            ),
            ui.input_checkbox(
                id="toggle_relative",  # checkbox switch
                label="Show Relative Values", 
                value=True  # Default to relative values
            ),
            ui.input_switch(
                id="toggle_swing",  # Toggle switch for swing states
                label="Show Only Swing States", 
                value=False  # Default to showing all states
            ),
            output_widget("state_map"),
            full_screen=True
        ),
        ui.card(
            ui.card_header("Selected Data"),
            ui.output_data_frame("data_table"),  # Use output_data_frame for rendering the table
            full_screen=True
        )
    )
)

### SERVER
def server(input, output, session):
    @reactive.Calc
    def selected_year_data():
        year = input.year_select()
        if year == "2012":
            return df2012
        elif year == "2016":
            return df2016
        elif year == "2020":
            return df2020
        elif year == "2024":
            return df2024

    @reactive.Calc
    def is_relative():
        return input.toggle_relative()

    @reactive.Calc
    def filtered_data():
        # Get the selected year and whether to show only swing states
        year = input.year_select()
        year_data = selected_year_data()
        is_swing_only = input.toggle_swing()

        # Merge geodata and year data
        merged = geodata.merge(year_data, on="NAME", how="left")

        # Filter to show only swing states if toggle is active
        if is_swing_only:
            swing_state_list = swing_states[year]
            merged = merged[merged["NAME"].isin(swing_state_list)]

        return merged

    @output
    @render_altair
    def state_map():
        # Get filtered data
        merged = filtered_data()

        # Convert merged GeoDataFrame to GeoJSON
        merged_json = json.loads(merged.to_json())

        # Determine which column to use for the map
        column_to_use = "VEP_relative" if is_relative() else "VEP"
        color_scale = (
            alt.Scale(domain=[-20, 0, 20], range=["blue", "white", "red"])
            if is_relative()
            else alt.Scale(domain=[40, 80], scheme="blues")
        )
        color_title = "Relative Turnout Rate (%)" if is_relative() else "Turnout Rate (%)"

        # Draw Altair map
        chart = alt.Chart(alt.Data(values=merged_json['features'])).mark_geoshape().encode(
            color=alt.Color(
                f'properties.{column_to_use}:Q',
                scale=color_scale,
                title=color_title
            ),
            tooltip=[
                alt.Tooltip('properties.NAME:N', title='State'),
                alt.Tooltip(f'properties.{column_to_use}:Q', title=color_title)
            ]
        ).properties(
            title=f"VEP Turnout Rate by State in {input.year_select()}",
            width=600,
            height=400
        ).project('albersUsa')

        return chart

    @output
    @render.data_frame
    def data_table():
        # Get the data for the selected year
        year_data = selected_year_data()

        # Return the filtered DataFrame
        return year_data

app = App(app_ui, server)

```




The third factor we are interested in is education. In this part, we are looking for the connection between the education level and the turnout rates. As a result, we have four education levels: post-college graduate, some or college graduate, high school graduate, and no high school. After that, we collect the data from the Election Lab at the University of Florida. The data are reweighted by the author using a procedure proposed by Hur and Achen. We filter the data and have a new data set of turnout rates by different eduation level. Finally, we draw the line chart with four different colors to present the change in turnout rates by education level from 1988 to 2020.

```{python}
# Load the dataset
data = pd.read_csv(r'C:\Users\james\Desktop\DAP_Final_Project\data\CPS_Demographic_Turnout_Rates_v1.0.csv')

# Specify the election years of interest
specified_years = [1988, 1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020]

# Convert 'YEAR' to integer for proper sorting and plotting in Altair
data['YEAR'] = data['YEAR'].astype(int)

# Filter the data for the specified years and melt it for Altair plotting
alt_data = data[data['YEAR'].isin(specified_years)][['YEAR', 'CPS_ADJ_NOHS_RATE', 'CPS_ADJ_HS_RATE', 'CPS_ADJ_COLLEGE_RATE', 'CPS_ADJ_POST_RATE']]
alt_data = alt_data.melt('YEAR', var_name='Education Level', value_name='Turnout Rate')

# Map original column names to more descriptive labels
education_label_map = {
    'CPS_ADJ_NOHS_RATE': 'No High School',
    'CPS_ADJ_HS_RATE': 'High School Graduate',
    'CPS_ADJ_COLLEGE_RATE': 'Some or College Graduate',
    'CPS_ADJ_POST_RATE': 'Post-College School'
}
alt_data['Education Level'] = alt_data['Education Level'].map(education_label_map)

# Create the Altair chart
chart = alt.Chart(alt_data).mark_line(point=True).encode(
    x=alt.X('YEAR:N', axis=alt.Axis(title='Year', labelAngle=0)),  # Treat year as nominal for custom sorting
    y=alt.Y('Turnout Rate:Q', axis=alt.Axis(title='Adjusted Turnout Rate')),
    color=alt.Color('Education Level:N', legend=alt.Legend(title="Education Level")),
    tooltip=['YEAR', 'Education Level', 'Turnout Rate']
).properties(
    title='Turnout Rate by Education Level for Specified U.S. Election Years',
    width=600,
    height=400
).configure_axis(
    grid=True
)

chart.display()

```

From the above chart, we can see that the citizens with higher education level have higher turnout rates. The citizens with post-college school degrees have the highest turnout rate, but the citizens without high school education have the lowest turnout rates. Additionally, the gaps of turnout rates between each education level are similar between 1988 and 2020 (around 15%).

To increase the turnout rates, there are three potential policy implications. The first one is to optimize the election policies between states. This one would help increase the turnout rates in the non-swing states. The second is to target the young voters. The turnout rates in young people are much lower than the old people. Motivating young people to vote can dramatically increase turnout rates. The third one is to focus on the low-education groups. The people with low education level have low turnout rates. Sensitizing them to the importance of voting might be one way to increase turnout rates.

However, there are some limitations in the project. The first one is the omitted variable bias. There would be other variables correlated with turnout rates and the above three factors, so biased outcome. Besides, Due to the data limitation, age, education cannot be classified as states level.Therefore, interaction effects between states and demographic variables could not be explored.

In order to study this topic in greater depth, the future direction should concentrate on exploring additional variables, using advanced modeling techniques, and expanding outcome measures about political participation. Additional variables would help to address the problem of biased outcome. The advanced modeling techniques, such as nonlinear regression, would show the correlation between these fators and turnout rates. Finally, turnout rates cannot be 100 percent to represent political participation, so the consideration of other measurements is also significant.

In conclusion, we believe that states, age, and education level are three factors affect the turnout rates. Although there are some limitations in the project, our project deserves a further research and more concentration.





























